package rs.ac.bg.etf.pp1;
import rs.ac.bg.etf.pp1.ast.*;
import java_cup.runtime.*;

parser code {:
	
	boolean errorDetected = false;

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left).append(": ").append(((Symbol) info).value);
        System.out.println(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left).append(": ").append(((Symbol) info).value);
        System.out.println(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		System.out.println(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, IF, NEW, PRINT, READ, RETURN, VOID, DO, WHILE, EXTENDS, CONTINUE, CONST;
terminal PLUS,MINUS,ASTERISK,SLASH,PERCENT,EQUALEQUAL,NOTEQUAL,GREATER,GREATEREQUAL,LESS,LESSEQUAL,AND,OR,EQUAL,PLUSPLUS,MINUSMINUS,SEMICOLON,COMMA,DOT,LPAREN,RPAREN,LSQUARE,RSQUARE,LBRACE,RBRACE;
terminal Integer NUMCONST;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;
terminal String IDENTIFIER;

non terminal program;
non terminal programDeclList, methodDecl;
non terminal programDecl;
non terminal constDecl, varDecl, classDecl;
non terminal type, constant;
non terminal varList;
non terminal var;
non terminal classExtension, localVarDecl, classMethodDecl;
non terminal returnType, formPars, statement;
non terminal formParsList;
non terminal designatorStatement;
non terminal designator, expr, actPars, condition;
non terminal actParsList;
non terminal condTerm, condFact, relop;
non terminal term, factor;
non terminal addop, mulop;
non terminal statementList;
non terminal constAssignmentList, constAssignment;
non terminal ifChainWithUnmatched, otherStatements;

program::=(Program) PROGRAM IDENTIFIER programDeclList LBRACE methodDecl RBRACE;
programDeclList::=(ProgramDeclarations) programDecl programDeclList | (NoProgramDeclarations) /*eps*/;
programDecl::=(ProgramDeclConstant) constDecl | (ProgramDeclVar) varDecl | (ProgramDeclClass) classDecl;
constDecl::=(ConstDecl) CONST type constAssignmentList SEMICOLON;
constAssignmentList::=(MultipleConstAssignments) constAssignment COMMA constAssignmentList | (OneConstAssignment) constAssignment;
constAssignment::=(ConstAssignment) IDENTIFIER EQUAL constant;
type::=(Type) IDENTIFIER;
constant::=(NumberConstant) NUMCONST | (CharacterConstant) CHARCONST | (BooleanConstant) BOOLCONST;
varDecl::=(VarDecl) type varList SEMICOLON;
varList::=(MultipleVarDecls) var COMMA varList | (OneVarDecl) var;
var::=(ScalarVar) IDENTIFIER | (ArrayVar) IDENTIFIER LSQUARE RSQUARE;
	//extends clause? ClassVarDecl?
classDecl::=(ClassDecl) CLASS IDENTIFIER classExtension LBRACE localVarDecl classMethodDecl RBRACE;
classExtension::=(Extension) EXTENDS type | (NoExtension) /*eps*/;
localVarDecl::=(LocalVarDeclarations) varDecl localVarDecl | (NoLocalVarDeclarations) /*eps*/;
classMethodDecl::=(ClassMethods) LBRACE methodDecl RBRACE | (NoClassMethods) /*eps*/;
methodDecl::=(MethodDeclarations) returnType IDENTIFIER LPAREN formPars RPAREN localVarDecl LBRACE statementList RBRACE methodDecl | (NoMethodDeclarations) /*eps*/;
returnType::=(ReturnTypeNonVoid) type | (ReturnTypeVoid) VOID;
formPars::=(FormalParameters) formParsList | (NoFormalParameters) /*eps*/;
formParsList::=(MultipleFormalParameters) type var COMMA formParsList | (OneFormalParameter) type var;
statementList::=(Statements) statement statementList | (NoStatements) /*eps*/;
statement::=(IfsUnmatched) ifChainWithUnmatched | (NotIfsUnmatched) otherStatements;
ifChainWithUnmatched::=(IfWithoutElse) IF LPAREN condition RPAREN statement | (IfWithUnmatchedInElse) IF LPAREN condition RPAREN otherStatements ELSE ifChainWithUnmatched;
otherStatements::=(StatementWithDesignator) designatorStatement SEMICOLON
			| (Break) BREAK SEMICOLON
			| (Continue) CONTINUE SEMICOLON
			| (Read) READ LPAREN designator RPAREN SEMICOLON
			| (PrintWithWidth) PRINT LPAREN expr COMMA NUMCONST RPAREN SEMICOLON
			| (PrintSimple) PRINT LPAREN expr RPAREN SEMICOLON
			| (ReturnVoid) RETURN SEMICOLON
			| (ReturnNonVoid) RETURN expr SEMICOLON
			| (IfWithMatchedInElse) IF LPAREN condition RPAREN otherStatements ELSE otherStatements
			| (DoWhileLoop) DO statement WHILE LPAREN condition RPAREN SEMICOLON
			| (StatementBlock) LBRACE statementList RBRACE;
designatorStatement::=(Assignment) designator EQUAL expr
					| (Increment) designator PLUSPLUS
					| (Decrement) designator MINUSMINUS
					| (FunctionCall) designator LPAREN actPars RPAREN;
actPars::=(ActualParameters) actParsList | (NoActualParameters) /*eps*/;
actParsList::=(MultipleActualParameters) expr COMMA actParsList | (OneActualParameter) expr;
condition::=(ConditionTerm) condTerm | (LogicalOr) condTerm OR condTerm;
condTerm::=(ConditionFact) condFact | (LogicalAnd) condFact AND condFact;
condFact::=(ConditionRelation) expr relop expr | (ConditionExpression) expr;
relop::=(EqualOp) EQUALEQUAL | (NotEqualOp) NOTEQUAL | (GreaterOp) GREATER | (GreaterOrEqualOp) GREATEREQUAL | (LessOp) LESS | (LessOrEqualOp) LESSEQUAL;
expr::=(ExpressionTerm) term | (ExpressionNegation) MINUS term | (ExpressionAddOp) expr addop term; //Negation here!?
term::=(TermFactor) factor | (TermMulOp) term mulop factor;
factor::=(FactorDesignator) designator | (FactorConstant) constant | (FactorExpressionInParentheses) LPAREN expr RPAREN | (FactorFunctionCall) designator LPAREN actPars RPAREN | (FactorNewClassInstance) NEW type | (FactorNewArrayAllocation) NEW type LSQUARE expr RSQUARE;
	//complexDesignator
designator::=(SimpleDesignator) IDENTIFIER | (ClassField) designator DOT IDENTIFIER | (ArrayElementDesignator) designator LSQUARE expr RSQUARE;
addop::=(AdditionOp) PLUS | (SubtractionOp) MINUS;
mulop::=(MultiplicationOp) ASTERISK | (DivisionOp) SLASH | (ModuleOp) PERCENT;